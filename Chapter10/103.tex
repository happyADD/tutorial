\textbf{导航需要地图。}


我们使用的是二维地图（毕竟小哨兵还没学会飞行，在z轴上运动能力为0（其实还有roll和pitch），而且二维导航相关的导航，定位，建图方案都比较成熟）
在机器人导航的时候，仅仅靠一张SLAM建立的原始地图是不够的，机器人在运动过程中可能会出现新的障碍物，
也有可能发现原始地图中某一块的障碍物消失了，所以在机器人导航过程中维护的地图是一个动态的地图。那么怎么样才能建立一个动态的地图呢？

\subsubsection{ 地图的获取}
首先，我们接收激光雷达扫描到的点云图，然后对其进行处理，压缩到二维，得到地图。

处理的第一步是进行点云的滤波。下面是一些常用的滤波方法：
\textbf{*注意：因为点云是通过物体表面反射光信息获取的，所以一个实体只有表面会有点云，内部是没有的。}
\begin{enumerate}
\item \textbf{Voxel滤波}：因为我们用的激光雷达比较牛逼，获得的近处点云比较稠密（保证远处的分辨率），这样直接计算会导致计算量过大，
为了防止出现“三帧电竞”的情况出现，我们可以将点云按照空间分辨率进行分割，又叫体素网格下采样。
\begin{tcode}
    pcl::VoxelGrid<pcl::PointXYZ> voxfilter;
    voxfilter.setInputCloud(cloud);
    // 设置滤波器的体素大小
    voxfilter.setLeafSize(0.1, 0.1, 0.1);
    voxfilter.filter(*cloud);
\end{tcode}
这样，我们就将cloud里每个0.1m*0.1m*0.1m的体素（三维空间中的一个小立方体单元）内的点替换为该体素的中心点。
将临近的点聚合到一个体素中来实现，可以减少点云数据的复杂度，同时保留整体的形状和结构。
\item \textbf{直通滤波}：直通滤波就是最简单的剔除不需要点云的滤波方法。比如小哨兵小小的，对它来说50cm以上的障碍物根本不影响他通过，那我们就可以把0.5m以上的点剔除掉。
\begin{tcode}
    pcl::PassThrough<pcl::PointXYZI> pass_through_filter_z_;
    pass_through_filter_z_.setFilterFieldName("z");
    pass_through_filter_z_.setFilterLimits(min_z, max_z);
    pass_through_filter_z_.setFilterLimitsNegative(false);
    pass_through_filter_z_.setInputCloud(input_cloud);
    pass_through_filter_z_.filter(*input_cloud);
\end{tcode}
这样，我们就将cloud里的z轴坐标在min\_z和max\_z之外的点剔除掉了。
同样的道理，还可以通过设置xy范围，把远处的，懒得考虑的点剔除掉。以及设置剔除一定半径内的点云，把哨兵本体的点云剔除掉。
\item \textbf{统计滤波}：在点云处理中，统计滤波是一种用于识别和移除离群点的方法，这些离群点可能是由于测量误差或噪声引起的。
该方法基于假设，即点云数据中的大部分点是符合高斯分布的，而离群点则是那些与这种分布显著不同的点。
\begin{tcode}
    pcl::StatisticalOutlierRemoval<pcl::PointXYZ> sor;
    sor.setInputCloud(cloud);
    // 设置近邻点的数量
    sor.setMeanK(50); 
    // 设置标准差倍数阈值
    sor.setStddevMulThresh(1.0); 
    // 设置为false表示移除离群点，设置为true表示保留离群点
    sor.setNegative(false); 
    sor.filter(*cloud);
\end{tcode}
通过这种方式，我们可以计算每个点到其K个最近邻点的平均距离，并根据这个平均距离与全局平均距离的比较来确定是否为离群点。
如果一个点的平均距离超过了全局平均距离加上标准差倍数的阈值，那么这个点就被认为是离群点并被移除。
这样可以有效地减少点云中的噪声和异常值，提高后续处理的准确性和效率。

\item \textbf{特殊方法滤波}：有时候一些特殊的物体需要滤掉，这时候就要自己编写特定的代码剔除。比如地板，是的，地板也是实体，也会产生点云，但他不是障碍物，所以需要过滤掉。
我们可以简单的通过直通滤波，把z轴坐标在轮子以下的点剔除掉。也可以通过聚类（即将点云数据中的点根据它们的空间位置或属性特征分组），将最大的聚类剔除掉，这样就剔除了地板。
而我们现在用的是tc学长写的法向量剔除法，计算每个点的法向量，然后剔除法向量与z平面夹角小于一定角度的点（通俗来说：平的就是地板）。
\end{enumerate}

现在，你就获取到了此时此刻哨兵周围的障碍物地图(准确来说是一个地图层：障碍层，下面会介绍)了。
然后，让哨兵动起来，经过赛场的每一个角落，将每一时刻获取的点云叠加起来
（通过我们上一节讲的定位方法就可以获取每一帧点云之间的相对位置，就可以进行拼接叠加了），就得到了一个完整的地图——这，就是建图
（比赛前会有哨兵建图环节，就是把赛场建成一张图。在陌生未知的环境下也可以一遍建图一遍在刚刚建出来的地图上进行导航）。
这张地图可以为三维点云格式（.pcd文件），也可以压缩成二维栅格地图格式（ .pgm, .png, .jpg文件），因为是按照真实世界按比例缩小，所以要有一个yaml文件来记录比例尺等参数来表示缩小比例。。

\textbf{*栅格地图：即用二维图片记录地图信息。用一个个像素表示地图上的障碍物的位置、大小信息，灰度表示障碍物置信度，支持pgm,png,jpg格式，可人工修改。
比如建完的图有一些噪声导致的奇怪黑点，我们就可以打开PhotoShop，用白色笔刷手动擦除；又如，我们不想让哨兵到某个地方，就可以用黑笔画地为牢，桀桀桀}

\subsubsection{ 地图的处理}
现在的地图以及可以满足定位这一功能的需求了，但是为了满足地图的另一功能——路径规划的需求，我们还需要对地图进行处理。

\paragraph{ 代价地图}
首先我们引入代价地图的概念,想要计算出最佳的路径，我们就要给每一条路径一个分值。所以我们把不想去的地方设置一个大大的代价，
比如我们不希望哨兵出现在障碍物的内部，那么就给把它的代价设为无穷大，在路径规划的时候路径就会避开它（具体的算法见10.4节）。

\paragraph{ 地图层layer}
为了让人们方便对地图进行自定义操作和拓展（“掺点小料”），nav2提供了一种非常灵活的地图处理机制，即地图的“层”，又叫$plugins$“插件”。
将一层层的地图层叠加在一起，就可以形成一个完整的地图（根据不同的需求，我们可以有很多张完整的地图，用在不同的地方，最常见的就是，
根据更新频率方式和用途不同，可以分为全局代价地图和局部代价地图）。
比如：

\textbf{global\_costmap全局代价地图}是用来进行全局路径规划的，一般包含
\begin{enumerate}
    \item $"static_layer"$静态层
    \item $"obstacle_layer"$障碍层
    \item $"inflation_layer"$膨胀层
\end{enumerate}
静态层一般就是之前SLAM建好的地图(.pgm文件),可以在上面进行路径规划。
障碍层用于动态的记录传感器感知到的障碍物信息。
但哨兵不是一个不计体积，不计质量，不计重力的理想质点。而路径规划又是按照质点来规划的，所以为了不让哨兵撞墙，膨胀层堂堂登场！

\textbf{膨胀层}通过将指定地图层（一般是所有下方地图层）里的障碍物膨胀
（就是把障碍物周围的点的代价加大，一般离障碍物越近代价越大，但不会到无穷大，可以自定义加大规则）
一定的距离（一般至少是机器人的半径，但建议能覆盖全图，形成一个势场），让路径规划的时候避开这些膨胀的障碍物。

\textbf{local\_costmap局部(本地)代价地图} 是用来进行局部路径规划的，一般包含
\begin{enumerate}
    \item {$obstacle\_layer$} 障碍层
    \item {$inflation\_layer$} 膨胀层
\end{enumerate}
    local\_costmap相比于global\_costmap，一般会限定一个较小的范围（如以机器人为中心的5m*m的正方形）以加快控制器计算速度。
这是因为控制器的计算复杂度比较高，且由于是通过直接发布速度控制信息（x,y线速度,yaw角速度）直接控制机器人的运动，发布频率越快越好。

*而且没必要。

对人类来说，永远不要担心2小时以后，和8公里以外的事情(哲学小课堂\~)。

而对于哨兵来说，
永远不要担心dt\_ref(轨迹时间分辨率)以后，和local\_costmap以外的事情。
但是因此要确保local\_costmap之外的障碍物不能影响到机器人的路径规划，换句话说，任何障碍物突然进入local\_costmap的范围内，
机器人都应该能从容优雅地避开，所以local\_costmap的极限范围与机器人的性能有关（最大速度，最大加速度）

还有一些其他地图层：
\begin{enumerate}
    \item $DenoiseLayer$：从最终成本图中去除椒盐噪声。
    \item $KeepoutFilter$：在成本图中标记禁止区、较高权重或较低权重的区域
    \item $SpeedFilter$：根据位置降低或提高机器人速度
\end{enumerate}
除了这些地图层，还可以自定义的地图层。比如你想哨兵不走回头路，那么你就可以把哨兵走过的路径当成障碍物，
变成一层地图层，添加在整张地图里，这样路径规划时就不会考虑这片区域了。

*值得注意的是，地图层之间是有顺序的。比如一般膨胀层都在最后（最上面），这样它就会把下面的静态层，障碍层，自定义层……都进行膨胀。
